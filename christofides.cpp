/**************************************************************************************************************
** Program name: Final Group Project
** Author: Derrick Li and Juan Du
** Date: Aug. 18, 2017
** Description: Implementation file of Christofides and 2-Opt Algorithm for TSP
***************************************************************************************************************/

#include "christofides.hpp"
#include "city.hpp"

#include <iostream>
#include <vector> 		/* vector */
#include <stack> 		/* stack */
#include <algorithm> 	/* remove */
#include <limits> 		/* max */
#include <deque> 		/* deque */
#include <string>

using std::endl;
using std::cout;
using std::flush;

using std::vector;
using std::deque;
using std::stack;

using std::string;

using std::make_heap;
using std::pop_heap;

using std::remove;

/* Maximum number of 2-opt passes */
const int MAX_NUM_OF_PASSES = 1000;

/* Defines constants inf and nil */
const int inf = std::numeric_limits<int>::max();
const int nil = -1;

/***************************************************************************************************************
** Description: Overload for the () operator for minimum priority queue to work with key data member of
** struct vertexAttributes.
***************************************************************************************************************/
struct comparator {
	bool operator() (const vertexAttributes *a, const vertexAttributes *b)
	{
		return a->key > b->key;
	}
};

/***************************************************************************************************************
** Description: Allocate memory for 2D array.
** @param: nVertices - number of rows/columns for 2D array
** @return: 2D array of nVertices x nVertices filled with 0
***************************************************************************************************************/
int** init2DArray(int nVertices)
{
	int **arr = new int*[nVertices];
	for (int i = 0; i < nVertices; i++)
	{
		arr[i] = new int[nVertices];
	}

	for (int i = 0; i < nVertices; i++)
	{
		for (int j = i; j < nVertices; j++)
		{
			arr[i][j] = arr[j][i] = 0;
		}
	}

	return arr;
}

/***************************************************************************************************************
** Description: Deallocates 2D array.
** @param: nVertices - number of row/columns of 2D array
** @param: arr - dynamically allocated 2D array
** @return: void
***************************************************************************************************************/
void delete2DArray(int nVertices, int** arr)
{
	for (int i = 0; i < nVertices; i++)
	{
		delete[] arr[i];
	}
	delete[] arr;
}

/***************************************************************************************************************
** Description: Cleans up the 2D arrays generated by the christofides function.
** @param: nVertices - number of row/columns of 2D array
** @param: mst - a 2D array representing the minimum spanning tree
** @param: mwpm - a 2D array representing the minimum weight perfect matching graph of vertices with odd degrees
** @param: cmg - a 2D array representing the connected multigraph of mst and mwpm
** @return: void
***************************************************************************************************************/
void cleanup(int nVertices, int** mst, int** mwpm, int** cmg)
{
	delete2DArray(nVertices, mst);
	delete2DArray(nVertices, mwpm);
	delete2DArray(nVertices, cmg);
}

/***************************************************************************************************************
** Description: Runs the christopher algorithm on supplied adjacency matrix.
** @param: nVertices - number of vertices (rows/colums) in adjacency matrix
** @param: adj - adjacency matrix
** @return: TSP path generated using the implemented Christofides algorithm
***************************************************************************************************************/
vector<int> christofides(int nVertices, int **adj)
{
	int root = 0;

	int** mst = MSTPrim(nVertices, adj, root);
	int** mwpm = minCostPerfectMatching(nVertices,adj, mst);
	int** cmg = combineMSTandMWPM(nVertices, mst, mwpm);
	vector<int> hamList = findEulerTourAndShortcut(nVertices, cmg);

	cleanup(nVertices, mst, mwpm, cmg);
	return hamList;
}

/***************************************************************************************************************
** Description: Implemenation of Prim's algorithm to find a minimum spanning tree.
** @param: nVertices - number of vertices (rows/colums) in adjacency matrix
** @param: adj - adjacency matrix
** @param: root - the vertex to start the minimum spanning tree
** @return: a 2D array representing the minimum spanning tree
***************************************************************************************************************/
int** MSTPrim(int nVertices, int **adj, int root)
{
	vertexAttributes *V = new vertexAttributes[nVertices];

	for (int i = 0; i < nVertices; i++)
	{
		V[i].id = i;
		V[i].key = inf;
		V[i].parent = nil;
		V[i].inQueue = true;
	}

	V[root].key = 0;

	vector<vertexAttributes *> Q;

	make_heap(Q.begin(), Q.end(), comparator());

	for (int i = 0; i < nVertices; i++)
	{
		Q.push_back(&V[i]);
	}

	while (!Q.empty())
	{
		make_heap(Q.begin(), Q.end(), comparator());
		vertexAttributes* u = Q.front();

		pop_heap(Q.begin(), Q.end(), comparator());
		Q.pop_back();
		u->inQueue = false;

		for (int i = 0; i < nVertices; i++)
		{
			vertexAttributes* v = &V[i];

			if (v->inQueue && adj[u->id][v->id] < v->key)
			{
				v->parent = u->id;
				v->key = adj[u->id][v->id];
			}
		}
	}

	int **mst = init2DArray(nVertices);

	for (int i = 0; i < nVertices; i++)
	{
		vertexAttributes *v = &V[i];
		if (v->parent != nil)
		{
			vertexAttributes *u = &V[v->parent];
			mst[u->id][v->id] = mst[v->id][u->id] = 1;   //1 denotes an edge
		}
	}

	delete[]V;

	return mst;
}

/***************************************************************************************************************
** Description: Implementation of a greedy approximation algorithm to find the minimum weight perfect matching
** graph of vertices with odd degrees.
** @param: nVertices - number of vertices (rows/colums) in adjacency matrix
** @param: adj - adjacency matrix
** @param: mst - a 2D array representing the minimum spanning tree
** @return: a 2D array representing the minimum weight perfect matching graph of vertices with odd degrees
***************************************************************************************************************/
int** minCostPerfectMatching(int nVertices, int **adj, int **mst)
{
	deque<vertexAttributes *> oddDegree;

	for (int i = 0; i < nVertices; i++)
	{
		int count = 0;

		for (int j = 0; j < nVertices; j++)
		{
			if (mst[i][j] > 0)
				count++;
		}

		if (count % 2 == 1)
		{
			vertexAttributes *temp = new vertexAttributes;
			temp->id = i;
			temp->key = inf;
			temp->parent = nil;
			temp->inQueue = false;

			oddDegree.push_back(temp);
		}
	}

	int **mwpm = init2DArray(nVertices);

	while (!oddDegree.empty())
	{
		vertexAttributes *u = oddDegree.back();
		oddDegree.pop_back();

		vertexAttributes *v = NULL;

		for (int i = 0; i < (signed) oddDegree.size(); i++)
		{
			v = oddDegree.at(i);

			if (adj[u->id][v->id] < u->key)
			{
				u->key = v->key = adj[u->id][v->id];
				u->parent = v->id;
				v->parent = u->id;
			}
		}

		oddDegree.erase(remove(oddDegree.begin(), oddDegree.end(), v), oddDegree.end());

		mwpm[u->id][v->id] = mwpm[v->id][u->id] = 1;   //1 denotes an edge

		delete u;
		delete v;
	}

	return mwpm;
}

/***************************************************************************************************************
** Description: Combines the MST and MWPM to create a connected multigraph.
** @param: nVertices - number of vertices (rows/colums) in adjacency matrix
** @param: mst - a 2D array representing the minimum spanning tree
** @param: mwpm - a 2D array representing the minimum weight perfect matching graph of vertices with odd degrees
** @return: a 2D array representing the connected multigraph of mst and mwpm
***************************************************************************************************************/
int** combineMSTandMWPM(int nVertices, int **mst, int** mwpm)
{
	int **cmg = init2DArray(nVertices);

	for (int i = 0; i < nVertices; i++)
	{
		for (int j = 0; j < nVertices; j++)
		{
			cmg[i][j] = mst[i][j] + mwpm[i][j];
		}
	}

	return cmg;
}

/***************************************************************************************************************
** Description: Outputs a list of vertices representing the TSP path as calculated by Christofides algorithm.
** @param: nVertices - number of vertices (rows/colums) in adjacency matrix
** @param: cmg - a 2D array representing the connected multigraph of mst and mwpm
** @return: a vector of ordered vertices representing the TSP path
***************************************************************************************************************/
vector<int> findEulerTourAndShortcut(int nVertices, int** cmg)
{
	vector<int> eulerList;
	vector<int> hamList;

	eulerAttributes *E = new eulerAttributes[nVertices];

	for (int i = 0; i < nVertices; i++)
	{
		E[i].id = i;
		E[i].numEdges = 0;
		E[i].isVisited = false;

		for (int j = 0; j < nVertices; j++)
		{
			E[i].numEdges += cmg[i][j];
		}
	}

	stack<eulerAttributes *> stack;

	int start = 0;
	eulerAttributes *u = &E[start];

	while (u != nullptr)
	{
		if (u->numEdges > 0)
		{
			stack.push(u);

			int neighbor = nil;
			for (int i = 0; i < nVertices; i++)
			{
				if (cmg[u->id][i] > 0)
				{
					neighbor = i;
					break;
				}
			}

			E[u->id].numEdges--;
			E[neighbor].numEdges--;

			cmg[u->id][neighbor]--;
			cmg[neighbor][u->id]--;

			u = &E[neighbor];
		}
		else
		{
			eulerList.push_back(u->id);

			if (!stack.empty())
			{
				u = stack.top();
				stack.pop();
			}
			else
			{
				u = nullptr;
			}
		}
	}

	for (int i = 0; i < (signed) eulerList.size(); i++)
	{
		eulerAttributes *vertex = &E[eulerList.at(i)];

		if (vertex->isVisited == false)
		{
			hamList.push_back(vertex->id);
			vertex->isVisited = true;
		}
	}

	delete[]E;

	return hamList;
}

/***************************************************************************************************************
** Description: Use 2-opt algorithm to improve TSP path.
** @param: nVertices - number of vertices (rows/colums) in adjacency matrix
** @param: hamList - a vector of ordered vertices representing the TSP path
** @param: adj - adjacency matrix
** @return: a vector of ordered vertices representing the TSP path using 2-opt algorithm
***************************************************************************************************************/
vector<int> twoOpt(int nVertices, vector<int> hamList, int **adj)
{
	vector<int> bestList = hamList;
	int bestDist = calculateTSPDistance(nVertices, adj, bestList);

	int count = 0;
	bool changed;

	cout << endl << "Working" << flush;

	do
	{
		changed = false;

		for (int i = 0; i < nVertices - 1; i++)
		{
			for (int k = i + 1; k < nVertices; k++)
			{
				vector<int> newHamList = twoOptSwap(nVertices, bestList, i, k);
				int newDist = calculateTSPDistance(nVertices, adj, newHamList);

				if (newDist < bestDist)
				{
					bestList = newHamList;
					bestDist = newDist;

					changed = true;
				}
			}
		}

		count++;
		cout << "." << flush;

	} while (count < MAX_NUM_OF_PASSES && changed);

	cout << endl << "Number of 2-Opt passes made: " << count << endl;

	return bestList;
}

/***************************************************************************************************************
** Description: Helper swapping funtion for the twoOpt function.
** @param: nVertices - number of vertices (rows/colums) in adjacency matrix
** @param: hamList - a vector of ordered vertices representing the TSP path
** @param: i - an index to do a swap
** @param: k - an index to do a swap
** @return: a vector of ordered vertices representing the TSP path
***************************************************************************************************************/
vector<int> twoOptSwap(int nVertices, vector<int> hamList, int i, int k)
{
	vector<int> newHamList;

	for (int a = 0; a < i ; a++)
	{
		newHamList.push_back(hamList.at(a));
	}
	for (int a = i; a <= k; a++)
	{
		newHamList.push_back(hamList.at(k - a + i));
	}
	for (int a = k + 1; a < nVertices; a++)
	{
		newHamList.push_back(hamList.at(a));
	}

	return newHamList;
}